/***
 *      _          _        __   
 *     | |    __ _| |__    / /_  
 *     | |   / _` | '_ \  | '_ \ 
 *     | |__| (_| | |_) | | (_) |
 *     |_____\__,_|_.__/   \___/ 
 *                               
 */

/*

This example adds a few items to lab 5 to show how to read the touch screen and render some graphics.

Some important highlights ( and changes since lab 5!!)

1.)    The CPU Runs at 180MHz.
2.)    The Scatter file has this added at the end:

	LR_EROM1 0x10000000 0x010000000  {    ; load region size_region
  ER_EROM1 0x10000000 0x010000000  {  ; load address = execution address
   *.o (ExtFlashSection)
  }
}

This allows us to place variables (in our case graphics) in the external SPIFI flash memory

3.)  The Board.c file adds a void BOARD_InitSPIFI_ExternalFlash(void) function.  This initializes the SPIFI controller
4.)  The pin_mux.c file adds some call to config the SPI9 (SPIFI) pins, I2C and a GPIO for the touch controller chip
5.)  The file fsl_ft506.c/.h  were brought in from the touch cursor project to be able to read the touch screen.   I edited to FT5406_Init to include code from the APP_I2C_init function from the touch_cursor project.

6.)   I stripped out all of the audio FFT routines so you can see how to do some graphics calls to include bitmaps.   Make sure to read the Lab 6 handout to understand how .png image files are
converted into C data structures.
7.)   This example also shows how to use a different font
8.)    I make my own "slider" using the graphics primitives.  This should give you an idea of how to make a slider.  If you are smart you will figure out a good way to extend the code so you can make additional sliders/widgets

*/


#include "board.h"
#include "fsl_debug_console.h"
#include "fsl_emc.h"
#include "pin_mux.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "eGFX.h"
#include "eGFX_Driver.h"
#include "FONT_5_7_1BPP.h"

#include "pin_mux.h"
#include "fsl_device_registers.h"
#include "fsl_i2c.h"
#include "fsl_i2s.h"
#include "fsl_wm8904.h"
#include "Audio.h"
#include "fsl_iocon.h"
#include "fsl_common.h"
#include "clock_config.h"
#include "fsl_power.h"

#include "fsl_i2c.h"
#include "fsl_ft5406.h"


//Sprites_16BPP_565.h & .c are autogenerated by the eGFX_Tools program in the eGFX folder.  There is a .bat that runs this program.  All you have to do is put .png files into the "Sprites" folder and run the GenSprites.bat file.
#include "Sprites_16BPP_565.h"

//Fonts are made with the eGFX_Fontgen.exe file that is eGFX Folder.  See the lab handout for some instructions on how to generate fonts.

#include "OCR_A_Extended__20px__Bold__SingleBitPerPixelGridFit_1BPP.h"
#include "Consolas__26px__Regular__AntiAliasGridFit_1BPP.h"
#include "Magneto__26px__Regular__AntiAliasGridFit_16BPP_565.h" 


/***
 *      __  __             _              
 *     |  \/  | ___  _ __ | | _____ _   _ 
 *     | |\/| |/ _ \| '_ \| |/ / _ \ | | |
 *     | |  | | (_) | | | |   <  __/ |_| |
 *     |_|__|_|\___/|_| |_|_|\_\___|\__, |
 *     / ___|| (_) __| | ___ _ __   |___/ 
 *     \___ \| | |/ _` |/ _ \ '__|        
 *      ___) | | | (_| |  __/ |           
 *     |____/|_|_|\__,_|\___|_|           
 *                                        
 */
 
 
 // Here I am going to define some symbols control the "area" of the screen where the slider will be.
 //Notive that the Sprite for the monkey is just a eGFX_ImagePlane struct and you get it the size of it
 //Remeber, sprites are autogenerated by the eGFX_Tools.exe program (which we run with the GenSprites.bat file)
 
 
 
 
#define SLIDER_REGION_START_Y   (18 + Sprite_16BPP_565_Slider.SizeY/2 + 20)
#define SLIDER_REGION_STOP_Y	 	(eGFX_PHYSICAL_SCREEN_SIZE_Y - 18 - Sprite_16BPP_565_Slider.SizeY/2)
 
#define SLIDER_REGION1_START_X	(18)
#define SLIDER_REGION1_STOP_X	 	(SLIDER_REGION1_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION2_START_X	SLIDER_REGION1_STOP_X + 16
#define SLIDER_REGION2_STOP_X	 	(SLIDER_REGION2_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION3_START_X	SLIDER_REGION2_STOP_X + 16
#define SLIDER_REGION3_STOP_X	 	(SLIDER_REGION3_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION4_START_X	SLIDER_REGION3_STOP_X + 16
#define SLIDER_REGION4_STOP_X	 	(SLIDER_REGION4_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION5_START_X	SLIDER_REGION4_STOP_X + 16
#define SLIDER_REGION5_STOP_X	 	(SLIDER_REGION5_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION6_START_X	SLIDER_REGION5_STOP_X + 16
#define SLIDER_REGION6_STOP_X	 	(SLIDER_REGION6_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION7_START_X	SLIDER_REGION6_STOP_X + 16
#define SLIDER_REGION7_STOP_X	 	(SLIDER_REGION7_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION8_START_X	SLIDER_REGION7_STOP_X + 16
#define SLIDER_REGION8_STOP_X	 	(SLIDER_REGION8_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION9_START_X	SLIDER_REGION8_STOP_X + 16
#define SLIDER_REGION9_STOP_X	 	(SLIDER_REGION9_START_X + Sprite_16BPP_565_Slider.SizeX )

#define SLIDER_REGION10_START_X	SLIDER_REGION9_STOP_X + 16
#define SLIDER_REGION10_STOP_X	 	(SLIDER_REGION10_START_X + Sprite_16BPP_565_Slider.SizeX )


#include "arm_math.h"
#include <math.h>
#include "Sprites_16BPP_565.h"
//#include "Magneto__26px__Regular__AntiAliasGridFit_16BPP_565.h"


// #########################################################################################################################

/***
 *      _  ___   ___  __  __ _   _        ____ _            _     
 *     / |( _ ) / _ \|  \/  | | | |____  / ___| | ___   ___| | __ 
 *     | |/ _ \| | | | |\/| | |_| |_  / | |   | |/ _ \ / __| |/ / 
 *     | | (_) | |_| | |  | |  _  |/ /  | |___| | (_) | (__|   <  
 *     |_|\___/ \___/|_|  |_|_| |_/___|  \____|_|\___/ \___|_|\_\ 
 *     / ___|  ___| |_ _   _ _ __                                 
 *     \___ \ / _ \ __| | | | '_ \                                
 *      ___) |  __/ |_| |_| | |_) |                               
 *     |____/ \___|\__|\__,_| .__/                                
 *                          |_|                                   
 */
 

//void BOARD_BootClock_PLL_RUN(void)
//{
//    POWER_DisablePD(kPDRUNCFG_PD_FRO_EN); /*!< Ensure FRO is on so that we can switch to its 12MHz mode temporarily*/
//   
//    POWER_SetVoltageForFreq(1800000000); /*!< Set voltage for core */
//    CLOCK_SetFLASHAccessCyclesForFreq(180000000); /*!< Set FLASH waitstates for core */
//	
//	  pll_config_t sys_pll_config = 
//		{
//        .desiredRate = 180000000, .inputRate = 12000000U,
//    };
//		
//		pll_setup_t sys_pll_setup;
//	
//		CLOCK_SetupPLLData(&sys_pll_config, &sys_pll_setup);
//    
//		sys_pll_setup.flags = PLL_SETUPFLAG_POWERUP | PLL_SETUPFLAG_WAITLOCK ;
//		
//    CLOCK_SetupSystemPLLPrec(&sys_pll_setup, sys_pll_setup.flags);
//		
//	  CLOCK_AttachClk(kSYS_PLL_to_MAIN_CLK);          /*!< Switch to 12MHz first to ensure we can change voltage without accidentally
//																										being below the voltage for current speed */
//		
//    SystemCoreClock = 180000000;                  /*!< Update information about frequency */
//}

/*

The ARM Cortex NVIC uses a table of function address to know where the CPU
should jump to when an interrupt is received from a peripheral.

Each peripheral has one or more "slots" in the table.    Chapter 3 (page 21) of the user manual
document these slots.  The DMIC is slot 25.

The interrupt table is defined in system_LPC54608.s (assembly language)
This code puts in placeholders in each of the vectors.   They are defined as "weak"
symbols meaning we can simply make a C function of the same name and then the address of the C function
will be put in the table.   This is magic done by the linker.

*/

#define BUFFER_SIZE 		1024
#define pi							3.14159

/* SLIDER POSIITONS VALUES FOR THE INTERUPT */
volatile float tuner1;
volatile float tuner2;
volatile float tuner3;
volatile float tuner4;
volatile float tuner5;

/* struct to define coeff arrays, a0, a1, a2, b0, b1, b2, will be normalized to a0 -> a1/a0, a2/a0, ... b2/a0 
Project notes are summaized below 	*/

typedef struct
{
	volatile float a[2];
	volatile float b[3];
	
} IIR_Coeffecients;

/* the buquiad filter feedforward and feebackward coefecient will be implented using a sample by sample computation method.
Because x[n-1], x[n-2] are emplyed due to the difference equation, after each computation of the current input, it is shifted down to the 
next time instance where x[n-1] = x[n], and x[n-2] = x[n -1], both haveing been intialized to zero. 

The feedbackward coeffecients are then computed in real time too, where the feedforward coefeceints are added to the input,
and then added using a summer, to that output signal. This entire project uses flaoting point numbers (f32). */



//BiQuad filter parameters
float SampleFreq = 44100; // Fs
float CenterFreq = 32;		// f0

/* Structs have to be intialized for both the coeff's, and the state. This means that each selection of a filter, whether it be band or pass
can be altered without the production of an entirely new function. */


/* Struct for states, this will be initialized to 0 later on, x_n, and y_n are the input and ouput and so initialized later in main */
typedef struct
{
	// feedforward
	float x_n_1;
	float x_n_2;
	
	// feedbackward
	float y_n_1;
	float y_n_2;
	
} StateData;



/* CODEC from here on... */

volatile uint32_t NextSampleOut = 0;
volatile uint32_t NextBufferReady = 0;
volatile float * left_buffer, * right_buffer; // usable data buffers

float  right_output_2kHz;
float  left_output_2kHz;
float  right_output_0_5kHz;
float  left_output_0_5kHz;
float  left_output_1kHz;
float  right_output_1kHz;
float  left_output_4kHz;
float  right_output_4kHz;
float  left_output_250Hz, right_output_250Hz;

	
int Index = 0;

// initilaize pointers to capture data from interupts

volatile float * left_background_buffer, * right_background_buffer; // background buffers for left and right channels
volatile float left_buffer_1of2[BUFFER_SIZE],  left_buffer_2of2[BUFFER_SIZE];    // left channel ping pong buffers
volatile float right_buffer_1of2[BUFFER_SIZE], right_buffer_2of2[BUFFER_SIZE];	  // right channel ping pong buffers


/*
	This union will be used to split 32-bit fifo data into 2 int16_t samples.
	Unions are uses to overlay several variable across the same memory.
*/
typedef union 
{
	uint32_t Data;
	int16_t Channel[2];
	
} I2S_FIFO_Data_t;

 

//################## START IIR FILTER  ############################ //

/* This next structure combines the states and coeffecients to make one strucutre to then adapt to the IIR filter */

/* function set backward flow parameters to zero until the singal propgates through forward flow coeffecients */

typedef struct
{
	StateData 						States;
	IIR_Coeffecients 			Coeffecients;
	uint8_t								Update;
	
} biQuad_parameters;

void initalize_IIR(biQuad_parameters *localSetToZero)
{
	
	localSetToZero->Update = 0;
	
	localSetToZero->States.y_n_1 = 0;
	localSetToZero->States.y_n_2 = 0;
	
	localSetToZero->States.x_n_1 = 0;
	localSetToZero->States.x_n_2 = 0;
	;
	
}


// COMPUTE COEFF'S
void coeffecient_computation(IIR_Coeffecients * coeff, float SampleFreq, float CenterFreq)
{		

		float w0;
		float alpha;
		/* instance coeff and will normalize by a0 */
		float a0, a1, a2, b0, b1, b2; 
		float Q = 1;
	
		/* find actual values and parameters*/
		w0 = 2.0*3.141592654*(CenterFreq/SampleFreq);
		alpha = sin(w0)/(2.0 * Q);
		
	
		/* compute and normalize coeffecient */
	  a0 =   1 + alpha;
	  a1 =  ( -2*cos(w0) ) / a0; 	a1 *= -1;
	  a2 =  ( 1 - alpha  ) / a0; 	a2 *= -1;		    
		b0 =  ( alpha ) / a0;	
		b1 =   0;
		b2 =  ( -alpha ) / a0;		
		a0 = 1;
		
		// negate feedforward coeff's
	
		/* send back the values to the location in memory using array initalizeation */
		coeff->a[0] = a1;
		coeff->a[1] = a2;		
		coeff->b[0] = b0;
		coeff->b[1] = b1;
		coeff->b[2] = b2;
		
}


void IIR_BiQuad_Filter(biQuad_parameters *Local_IIR_set , float * Input, volatile float * Output) // output buffer is a pointer
{
    float stage;
		/* y[n] = b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] - a1 * y[n-1] - a2 * y[n-2]*/
  

    stage = ( * Input ) * Local_IIR_set->Coeffecients.b[0];
		// go through next STAGE 
      stage +=  Local_IIR_set->States.x_n_1 * Local_IIR_set->Coeffecients.b[1];
      stage +=  Local_IIR_set->States.x_n_2 * Local_IIR_set->Coeffecients.b[2];
      stage +=  Local_IIR_set->States.y_n_1 * Local_IIR_set->Coeffecients.a[0];
      stage +=  Local_IIR_set->States.y_n_2 * Local_IIR_set->Coeffecients.a[1];

		// 
    Local_IIR_set->States.y_n_2 =  Local_IIR_set->States.y_n_1;
    Local_IIR_set->States.y_n_1 =  stage;
    Local_IIR_set->States.x_n_2 =  Local_IIR_set->States.x_n_1;
    Local_IIR_set->States.x_n_1 =  *Input;
    *Output = stage;
}


//################## END IIR FILTER ############################ //

float	 FFT_RawDataOut[BUFFER_SIZE];
float  FFT_PowerSpectrum[BUFFER_SIZE];



//################## START FLEXCOM PERIPHERALS  ############################ //



void FLEXCOMM6_DriverIRQHandler(void)
{
    if (I2S0->FIFOINTSTAT & I2S_FIFOINTSTAT_TXLVL_MASK)
    {
        /*
					NextSampleOut Holds the last value from the I2S RX Interrupt.
				  It is also ready in the "packed" FIFO format
			  */
				I2S0->FIFOWR = NextSampleOut;
		
				 /* Clear TX level interrupt flag */
        I2S0->FIFOSTAT = I2S_FIFOSTAT_TXLVL(1U);
		}
}

//IIR_Coeffecients    currentCoeff;
//biQuad_parameters 	yStatesToZero;

biQuad_parameters  	IIR_States_Coeff_250Hz;
biQuad_parameters  	IIR_States_Coeff_500Hz;
biQuad_parameters  	IIR_States_Coeff_1kHz;
biQuad_parameters  	IIR_States_Coeff_2Khz;
biQuad_parameters  	IIR_States_Coeff_4kHz;

/* band buffers */
volatile float left_250Hz_buffer[BUFFER_SIZE], right_250Hz_buffer[BUFFER_SIZE]; 
volatile float left_500Hz_buffer[BUFFER_SIZE], right_500Hz_buffer[BUFFER_SIZE];
volatile float left_1kHz_buffer[BUFFER_SIZE], right_1kHz_buffer[BUFFER_SIZE]; 
volatile float left_2kHz_buffer[BUFFER_SIZE], right_2kHz_buffer[BUFFER_SIZE]; 
volatile float left_4kHz_buffer[BUFFER_SIZE], right_4kHz_buffer[BUFFER_SIZE]; 
volatile float request_new_buffer = 0;
double Fs = 44100;

void FLEXCOMM7_DriverIRQHandler(void)
{
	
 	 float LeftChannel;
	 float RightChannel;
	 I2S_FIFO_Data_t FIFO_Data;
	
	 I2S1->FIFOSTAT = I2S_FIFOSTAT_RXLVL(1U);
	 FIFO_Data.Data = I2S1->FIFORD; 				// Read the Recieve FIFO
	 //NextSampleOut = FIFO_Data.Data; 		  // dump the data back out
	
	 LeftChannel  = (float)(FIFO_Data.Channel[0])/32768.0f; // The Right Channel is in the upper 16-bits and the Left-Channel is the lower
	 RightChannel = (float)(FIFO_Data.Channel[1])/32768.0f;
	 //250
	 IIR_BiQuad_Filter( &IIR_States_Coeff_250Hz, &LeftChannel,  &left_output_250Hz);
	 IIR_BiQuad_Filter( &IIR_States_Coeff_250Hz, &RightChannel, &right_output_250Hz);
	 //500
	 IIR_BiQuad_Filter( &IIR_States_Coeff_500Hz, &LeftChannel,  &left_output_0_5kHz);
	 IIR_BiQuad_Filter( &IIR_States_Coeff_500Hz, &RightChannel, &right_output_0_5kHz);
	 //1000
	 IIR_BiQuad_Filter( &IIR_States_Coeff_1kHz, &LeftChannel,  &left_output_1kHz);
	 IIR_BiQuad_Filter( &IIR_States_Coeff_1kHz, &RightChannel, &right_output_1kHz);
   //2000
	 IIR_BiQuad_Filter( &IIR_States_Coeff_2Khz, &LeftChannel, &left_output_2kHz);
	 IIR_BiQuad_Filter( &IIR_States_Coeff_2Khz, &RightChannel, &right_output_2kHz);	
	 //4000
	 IIR_BiQuad_Filter( &IIR_States_Coeff_4kHz, &LeftChannel,  &left_output_4kHz);
	 IIR_BiQuad_Filter( &IIR_States_Coeff_4kHz, &RightChannel, &right_output_4kHz);
	 	
   
	if(request_new_buffer == 1)
	{
		
		// 250
		left_250Hz_buffer[Index]  = left_output_250Hz; 
		right_250Hz_buffer[Index] = right_output_250Hz;
		
		/* 500Hz */		  	  
		left_500Hz_buffer[Index]  = left_output_0_5kHz; 
		right_500Hz_buffer[Index] = right_output_0_5kHz;
			
		/* 1000Hz */		  	  
		left_1kHz_buffer[Index]  = left_output_1kHz; 
		right_1kHz_buffer[Index] = right_output_1kHz;
	
		/* 2000Hz */ 		
	  left_2kHz_buffer[Index]  = left_output_2kHz; 
		right_2kHz_buffer[Index] = right_output_2kHz;
		
			
		/* 4000Hz */		  	  
		left_4kHz_buffer[Index]  = left_output_4kHz; 
		right_4kHz_buffer[Index] = right_output_4kHz;
		
		Index++;
		
		if(Index == BUFFER_SIZE)
			{ /* set flag to yes, buffer is ready */
					request_new_buffer = 0;
					Index = 0;
			}		
		
	}		
	
	volatile uint32_t left_signalOut = (left_output_250Hz * tuner1)
																	+ (left_output_0_5kHz * tuner2)
																	+ (left_output_1kHz * tuner3)
																	+ (left_output_2kHz * tuner4)
																	+ (left_output_4kHz * tuner5);
	
		volatile uint32_t right_signalOut = (right_output_250Hz * tuner1)
																	+ (right_output_0_5kHz * tuner2)
																	+ (right_output_1kHz * tuner3)
																	+ (right_output_2kHz * tuner4)
																	+ (right_output_4kHz * tuner5);
	 
	 //NextSampleOut = ( (int32_t)(left_signalOut * 32768.0f) << 16 )
	 	//										+ (int32_t)(right_signalOut * 32768.0f ); 
		
			 
	 NextSampleOut =  ( (int32_t)( ( (left_output_250Hz * tuner1) + (left_output_0_5kHz * tuner2) + 
										(right_output_1kHz * tuner3) + (left_output_2kHz * tuner4) + (left_output_4kHz * tuner5)) * 32768.0f) << 16 )
	 											+  (int32_t)(( (right_output_250Hz *tuner1) + (right_output_0_5kHz * tuner2)+ 
											(right_output_1kHz * tuner3)+ (right_output_2kHz * tuner4)+ (right_output_4kHz * tuner5) ) * 32768.0f ); 

		
}

void initializeBuffers(void)
{
	for (int i = 0 ; i < BUFFER_SIZE ;i++)
	{
		
		left_buffer_1of2[i]  = 0;
		left_buffer_2of2[i]  = 0;
		right_buffer_1of2[i] = 0;
		right_buffer_2of2[i] = 0;
		
	}

	right_buffer = right_buffer_1of2;
	left_buffer  = left_buffer_1of2;

	right_background_buffer = right_buffer_2of2;
	left_background_buffer  = left_buffer_2of2;
	

	NextBufferReady = 0;
}



/***
 *      ____            _   _      _                
 *     / ___| _   _ ___| |_(_) ___| | __            
 *     \___ \| | | / __| __| |/ __| |/ /            
 *      ___) | |_| \__ \ |_| | (__|   <             
 *     |____/ \__, |___/\__|_|\___|_|\_\            
 *      ___   |___/                             _   
 *     |_ _|_ __ | |_ ___ _ __ _ __ _   _ _ __ | |_ 
 *      | || '_ \| __/ _ \ '__| '__| | | | '_ \| __|
 *      | || | | | ||  __/ |  | |  | |_| | |_) | |_ 
 *     |___|_| |_|\__\___|_|  |_|   \__,_| .__/ \__|
 *                                       |_|        
 */
 
#define TEST1_PORT 4
#define TEST1_PIN  6

#define TEST2_PORT 3
#define TEST2_PIN  21



int main(void)
{
	
		//Some temporary variables for reading the touch screen
  	int32_t x=10,y=10;
		
	 //We are going to make a variable that stores the coordinate of the slider. 
	 //I will instialize the value to somewhere in the middle
  
		volatile float SliderPosition6  = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;
		volatile float SliderPosition7  = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;
		volatile float SliderPosition8  = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;
		volatile float SliderPosition9  = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;
		volatile float SliderPosition10 = (SLIDER_REGION_STOP_Y + SLIDER_REGION_START_Y)/2;

	
	
		//some variables for the touch screen driver
    ft5406_handle_t touch_handle;   
		touch_event_t touch_event;		
    CLOCK_EnableClock(kCLOCK_InputMux);		
    CLOCK_EnableClock(kCLOCK_Iocon);	
    CLOCK_EnableClock(kCLOCK_Gpio0);  
    CLOCK_EnableClock(kCLOCK_Gpio1);		
    CLOCK_EnableClock(kCLOCK_Gpio2);  
    CLOCK_EnableClock(kCLOCK_Gpio3);			
    CLOCK_EnableClock(kCLOCK_Gpio4);		
		CLOCK_EnableClock(kCLOCK_FlexComm2);
		
    CLOCK_AttachClk(BOARD_DEBUG_UART_CLK_ATTACH);
    BOARD_InitPins();			
    BOARD_BootClock_PLL_RUN();  
    BOARD_InitDebugConsole();
		BOARD_InitSPIFI_ExternalFlash();
		BOARD_InitSDRAM();
		eGFX_InitDriver();
		
		
		

		/* 2kHz */
		initalize_IIR( &IIR_States_Coeff_2Khz ); /* set intial y parameters and update to zero */		
	  coeffecient_computation( &IIR_States_Coeff_2Khz.Coeffecients , Fs, 2000 ); /* compute coeffeceients for first band */	
		/* 500Hz */
		initalize_IIR( &IIR_States_Coeff_500Hz ); /* set intial y parameters and update to zero */		
	  coeffecient_computation( &IIR_States_Coeff_500Hz.Coeffecients , Fs, 500 );
		/* 250Hz */
		initalize_IIR( &IIR_States_Coeff_250Hz ); /* set intial y parameters and update to zero */		
	  coeffecient_computation( &IIR_States_Coeff_250Hz.Coeffecients , Fs, 250 );
		/* 1000Hz */
		initalize_IIR( &IIR_States_Coeff_1kHz ); /* set intial y parameters and update to zero */		
	  coeffecient_computation( &IIR_States_Coeff_1kHz.Coeffecients , Fs, 1000 );
		/* 4000Hz */
		initalize_IIR( &IIR_States_Coeff_4kHz ); /* set intial y parameters and update to zero */		
	  coeffecient_computation( &IIR_States_Coeff_4kHz.Coeffecients , Fs, 4000 );
		
		InitAudio_CODEC();
	 
		IOCON_PinMuxSet(IOCON, TEST1_PORT, TEST1_PIN, IOCON_FUNC0 | IOCON_MODE_INACT| IOCON_DIGITAL_EN);

    IOCON_PinMuxSet(IOCON, TEST2_PORT, TEST2_PIN, IOCON_FUNC0 | IOCON_MODE_INACT| IOCON_DIGITAL_EN);
		
	  GPIO->DIR[TEST1_PORT] |= 1<<TEST1_PIN;
	 
	  GPIO->DIR[TEST2_PORT] |= 1<<TEST2_PIN;
		
		
	 
	  //SysTick_Config(SystemCoreClock/1000);
    


		
		FT5406_Init(&touch_handle,I2C2);
	
		
		
		while(1)
		{
			request_new_buffer = 1;

			while(request_new_buffer == 1)
			{
			}
				
				eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
			
			

					
				// ##### CALCULATE RMS TO DISPLAY ENTENSITY #####				
				volatile float summation_left[10]  = {0};
				volatile float summation_right[10] = {0};
				double rms_value_t[10], rms_value_r[10];
					
				// SUM SQUARE ALL ELLEMENTS
				for(int indx = 0 ; indx < 1024 ; indx++)
				{
					// 2kHz
					summation_left[0]  += pow( left_250Hz_buffer [indx], 2);		
					summation_right[0] += pow( right_250Hz_buffer[indx], 2);
					//
					summation_left[1]  += pow( left_500Hz_buffer [indx], 2);		
					summation_right[1] += pow( right_500Hz_buffer[indx], 2);
					
					summation_left[2]  += pow( left_1kHz_buffer [indx], 2);		
					summation_right[2] += pow( right_1kHz_buffer[indx], 2);
					
					summation_left[3]  += pow( left_2kHz_buffer [indx], 2);		
					summation_right[3] += pow( right_2kHz_buffer[indx], 2);
					
					summation_left[4]  += pow( left_4kHz_buffer [indx], 2);		
					summation_right[4] += pow( right_4kHz_buffer[indx], 2);
				}			
			
			// CALC RMS
			rms_value_t[0] = sqrt(summation_left[0] / 1024);	
			rms_value_r[0] = sqrt(summation_right[0] / 1024);
				
			rms_value_t[1] = sqrt(summation_left[1] / 1024);	
			rms_value_r[1] = sqrt(summation_right[1] / 1024);
				
			rms_value_t[2] = sqrt(summation_left[2] / 1024);	
			rms_value_r[2] = sqrt(summation_right[2] / 1024);
				
			rms_value_t[3] = sqrt(summation_left[3] / 1024);	
			rms_value_r[3] = sqrt(summation_right[3] / 1024);
				
			rms_value_t[4] = sqrt(summation_left[4] / 1024);	
			rms_value_r[4] = sqrt(summation_right[4] / 1024);

			eGFX_ImagePlane_Clear(&eGFX_BackBuffer);
			
		  /* draw the background (sprites) to the back buffer */
			//eGFX_Blit(&eGFX_BackBuffer,0,0, &Sprite_16BPP_565_background);
				
			// ##### TEMP DISPLAY SIGNAL #####	
			for(int i = 1 ; i < eGFX_PHYSICAL_SCREEN_SIZE_X ; i++)
			{
				
				float point_r1 = (right_2kHz_buffer[i-1] * (eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
				float point_r2 = (right_2kHz_buffer[i]   * (eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
				float point_l1 = (left_2kHz_buffer[i-1]  * (eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
				float point_l2 = (left_2kHz_buffer[i]    * (eGFX_PHYSICAL_SCREEN_SIZE_Y/2));
				
				
//				eGFX_DrawLine( &eGFX_BackBuffer,                          
//				i-1		,		point_l1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0-32,       
//				i		  ,   point_l2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0-32, 	
//				eGFX_RGB888_TO_RGB565(0,255,0) );
//				

//				eGFX_DrawLine( &eGFX_BackBuffer,                        
//				i-1		,		point_r1+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0+32,       
//				i		  ,   point_r2+eGFX_PHYSICAL_SCREEN_SIZE_Y/2.0+32, 
//				eGFX_RGB888_TO_RGB565(0,255,255) );
				
			}
			
			
			
			/* IMPORTANT: x screen size is 480, so a 10 band equalizer would have a pixel space of about 50 pixels/band */
			/* 480 x 272 for background image */
				
			// ##### DISPLAY EQ BAR per buffer #####
			
			
			

								
		
			
			
			 //read in the x,y coordinate of the the touch sensor if there is a good reading.
        if (kStatus_Success == FT5406_GetSingleTouch(&touch_handle, &touch_event, &y, &x))
        {
					
					
            if (touch_event == kTouch_Contact)
            {
								/*/Check to see if we are in the slider area
							  /if(	 x>=SLIDER_REGION1_START_X && x<=SLIDER_REGION1_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition1 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition1 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition1 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION2_START_X && x<=SLIDER_REGION2_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition2 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition2 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition2 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION3_START_X && x<=SLIDER_REGION3_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition3 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition3 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition3 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION4_START_X && x<=SLIDER_REGION4_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition4 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition4 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition4 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION5_START_X && x<=SLIDER_REGION5_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition5 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition5 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition5 = SLIDER_REGION_START_Y;
								}*/
								if(	 x>=SLIDER_REGION6_START_X && x<=SLIDER_REGION6_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition6 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition6 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition6 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION7_START_X && x<=SLIDER_REGION7_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition7 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition7 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition7 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION8_START_X && x<=SLIDER_REGION8_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition8 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition8 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition8 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION9_START_X && x<=SLIDER_REGION9_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition9 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition9 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition9 = SLIDER_REGION_START_Y;
								}
								if(	 x>=SLIDER_REGION10_START_X && x<=SLIDER_REGION10_STOP_X)
								{
										//Store the Value
									if (y<=SLIDER_REGION_STOP_Y && y>=SLIDER_REGION_START_Y)SliderPosition10 = y;
									else if (y>SLIDER_REGION_STOP_Y) 												SliderPosition10 = SLIDER_REGION_STOP_Y;
									else if (y<SLIDER_REGION_START_Y) 											SliderPosition10 = SLIDER_REGION_START_Y;
								}
            }
						
						PRINTF("Touch \r\n");
        }
				else
				{
					PRINTF("Touch Failed\r\n");
				}
				
				//The variable MonkeySliderPosition is the Y coordinate of the slider.  
				//Let's normalize this value to 0 to 1.0 so we can easily rescale to something else later.
				
//				float	SliderValue1  =  1 - (float)(SliderPosition1 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);
//				float	SliderValue2  =  1 - (float)(SliderPosition2 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
//				float	SliderValue3  =  1 - (float)(SliderPosition3 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
//				float	SliderValue4  =  1 - (float)(SliderPosition4 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
//				float	SliderValue5  =  1 - (float)(SliderPosition5 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
				float	SliderValue6  =  1 - (float)(SliderPosition6 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
				float	SliderValue7  =  1 - (float)(SliderPosition7 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);	
				float	SliderValue8  =  1 - (float)(SliderPosition8 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);
				float	SliderValue9  =  1 - (float)(SliderPosition9 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);
				float	SliderValue10 =  1 - (float)(SliderPosition10 - SLIDER_REGION_START_Y)/(float)(SLIDER_REGION_STOP_Y-SLIDER_REGION_START_Y);				
		
				//Render the Slider
				
				//First, let's draw a box for the slider fill.   There is eGFX function to make a box
				
				//eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox5,eGFX_RGB888_TO_RGB565(128,128,128));
				
				//BOX6
				eGFX_Box SliderFillBox6;

				SliderFillBox6.P1.X = 	(SLIDER_REGION6_START_X);   
				SliderFillBox6.P1.Y = 	(SliderPosition6 - Sprite_16BPP_565_Slider.SizeY/2);
				SliderFillBox6.P2.X = 	(SLIDER_REGION6_STOP_X);
				SliderFillBox6.P2.Y = 	(SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2);
				
				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox6,eGFX_RGB888_TO_RGB565(0,0,255));
				
				//BOX7
				eGFX_Box SliderFillBox7;

				SliderFillBox7.P1.X = 	(SLIDER_REGION7_START_X);   
				SliderFillBox7.P1.Y = 	(SliderPosition7 - Sprite_16BPP_565_Slider.SizeY/2);
				SliderFillBox7.P2.X = 	(SLIDER_REGION7_STOP_X);
				SliderFillBox7.P2.Y = 	(SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2);
				
				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox7,eGFX_RGB888_TO_RGB565(255,0,255));
				
				//BOX8
				eGFX_Box SliderFillBox8;

				SliderFillBox8.P1.X = 	(SLIDER_REGION8_START_X);   
				SliderFillBox8.P1.Y = 	(SliderPosition8 - Sprite_16BPP_565_Slider.SizeY/2);
				SliderFillBox8.P2.X = 	(SLIDER_REGION8_STOP_X);
				SliderFillBox8.P2.Y = 	(SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2);

				
				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox8,eGFX_RGB888_TO_RGB565(0,255,0));
				
				//BOX9
				eGFX_Box SliderFillBox9;

				SliderFillBox9.P1.X = 	(SLIDER_REGION9_START_X);   
				SliderFillBox9.P1.Y = 	(SliderPosition9 - Sprite_16BPP_565_Slider.SizeY/2);
				SliderFillBox9.P2.X = 	(SLIDER_REGION9_STOP_X);
				SliderFillBox9.P2.Y = 	(SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2);
				
				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox9,eGFX_RGB888_TO_RGB565(255,255,0));
				
				//BOX5
				eGFX_Box SliderFillBox10;

				SliderFillBox10.P1.X = 	(SLIDER_REGION10_START_X);   
				SliderFillBox10.P1.Y = 	(SliderPosition10 - Sprite_16BPP_565_Slider.SizeY/2);
				SliderFillBox10.P2.X = 	(SLIDER_REGION10_STOP_X);
				SliderFillBox10.P2.Y = 	(SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2);
				
				eGFX_DrawFilledBox(&eGFX_BackBuffer,&SliderFillBox10,eGFX_RGB888_TO_RGB565(255,0,0));
				
				//Now let's draw the monkey head. The "blit" function just copies one ImagePlane to another.
				//In this case we will copy the monkey head to our back buffer
				
				/*eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION1_START_X,  //x coordinate of where to put the monkey head
								SliderPosition1 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);				

				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION2_START_X,  //x coordinate of where to put the monkey head
								SliderPosition2 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION3_START_X,  //x coordinate of where to put the monkey head
								SliderPosition3 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION4_START_X,  //x coordinate of where to put the monkey head
								SliderPosition4 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION5_START_X,  //x coordinate of where to put the monkey head
								SliderPosition5 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);*/
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION6_START_X,  //x coordinate of where to put the monkey head
								SliderPosition6 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION7_START_X,  //x coordinate of where to put the monkey head
								SliderPosition7 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION8_START_X,  //x coordinate of where to put the monkey head
								SliderPosition8 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION9_START_X,  //x coordinate of where to put the monkey head
								SliderPosition9 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
				eGFX_Blit(&eGFX_BackBuffer,
								SLIDER_REGION10_START_X,  //x coordinate of where to put the monkey head
								SliderPosition10 - Sprite_16BPP_565_Slider.SizeY/2,																			 //y coordinate of where to put the monkey head
								&Sprite_16BPP_565_Slider);
								
								
			
			
			  //Let's draw some lines on the left and right to define our boundaries
				//Boundries 1
				/*eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION1_START_X,SLIDER_REGION1_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION1_START_X,SLIDER_REGION1_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION1_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION1_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));

				//Boundries 2
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION2_START_X,SLIDER_REGION2_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION2_START_X,SLIDER_REGION2_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION2_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION2_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));

				//Boundries 3
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION3_START_X,SLIDER_REGION3_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION3_START_X,SLIDER_REGION3_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION3_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION3_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));

				//Boundries 4
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION4_START_X,SLIDER_REGION4_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION4_START_X,SLIDER_REGION4_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION4_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION4_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));

				//Boundries 5
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION5_START_X,SLIDER_REGION5_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION5_START_X,SLIDER_REGION5_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION5_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION5_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  */

				//Boundries 6
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION6_START_X,SLIDER_REGION6_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION6_START_X,SLIDER_REGION6_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION6_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION6_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  
				//Boundries 7
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION7_START_X,SLIDER_REGION7_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION7_START_X,SLIDER_REGION7_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION7_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION7_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  
				//Boundries 8
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION8_START_X,SLIDER_REGION8_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION8_START_X,SLIDER_REGION8_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION8_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION8_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  
				//Boundries 9
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION9_START_X,SLIDER_REGION9_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION9_START_X,SLIDER_REGION9_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION9_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION9_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  
				//Boundries 10
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION10_START_X,SLIDER_REGION10_STOP_X,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawHline(&eGFX_BackBuffer,SLIDER_REGION10_START_X,SLIDER_REGION10_STOP_X,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,eGFX_RGB888_TO_RGB565(255,255,255));
				
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION10_START_X,eGFX_RGB888_TO_RGB565(255,255,255));
				eGFX_DrawVline(&eGFX_BackBuffer,SLIDER_REGION_START_Y - Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION_STOP_Y + Sprite_16BPP_565_Slider.SizeY/2,SLIDER_REGION10_STOP_X,eGFX_RGB888_TO_RGB565(255,255,255));
			  
				// 250
			/* tuners for each band*/
			
			tuner1 = 1-SliderPosition6/244;
			tuner2 = 1-SliderPosition7/244;
			tuner3 = 1-SliderPosition8/244;
			tuner4 = 1-SliderPosition9/244;
			tuner5 = 1-SliderPosition10/244;
			
				
			for(int j = 0; j <= 20 ; j++)
			{	
					eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_t[0]*(1-SliderPosition6/244)*1000,
														j,
														eGFX_RGB888_TO_RGB565(0,0,255));
			}	
			
			for( int z = 20 ; z <= 40 ; z++ )
			{
				eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_r[0]*(1-SliderPosition6/244)*1000,
														z,
														eGFX_RGB888_TO_RGB565(0,0,255));
			}
			
			tuner1 = 1-SliderPosition6/244;
			
			//500
			
			for(int j = 50; j <= 70 ; j++)
			{	
					eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_t[1]*(1-SliderPosition7/244)*1000,
														j,
														eGFX_RGB888_TO_RGB565(255,51,153)); 
			}	
			
			for( int z = 70 ; z <= 90 ; z++ )
			{
				eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_r[1]*(1-SliderPosition7/244)*1000,
														z,
														eGFX_RGB888_TO_RGB565(255,51,153));
			}
			
			//1000
			
			for(int j = 100; j <= 120 ; j++)
			{	
					eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_t[2]*(1-SliderPosition8/244)*1000,
														j,
														eGFX_RGB888_TO_RGB565(0,204,102));
			}	
			
			for( int z = 120 ; z <= 140 ; z++ )
			{
				eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_r[2]*(1-SliderPosition8/244)*1000,
														z,
														eGFX_RGB888_TO_RGB565(0,204,102));
			}
			//2000
			
			for(int j = 150; j <= 170 ; j++)
			{	
					eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_t[3]*(1-SliderPosition9/244)*1000,
														j,
														eGFX_RGB888_TO_RGB565(255,255,51));
			}	
			
			for( int z = 170 ; z <= 190 ; z++ )
			{
				eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_r[3]*(1-SliderPosition9/244)*1000,
														z,
														eGFX_RGB888_TO_RGB565(255,255,51));
			}
			
      //4000
			for(int j = 200; j <= 220 ; j++)
			{	
					eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_t[4]*(1-SliderPosition10/244)*1000,
														j,
														eGFX_RGB888_TO_RGB565(255,0,0));
			}	
			
			for( int z = 220 ; z <= 240 ; z++ )
			{
				eGFX_DrawVline(&eGFX_BackBuffer,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1,
														eGFX_PHYSICAL_SCREEN_SIZE_Y-1.0 - rms_value_r[4]*(1-SliderPosition10/244)*1000,
														z,
														eGFX_RGB888_TO_RGB565(255,0,0));
			}
				
				//The last step is to dump the backbuffer to the screen.
				eGFX_Dump(&eGFX_BackBuffer);
		}
}



